import OpenAI from 'openai';
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';
import { logger } from '@/lib/error-logger';
import sharp from 'sharp';

// Helper function to create a timeout promise
const withTimeout = <T>(promise: Promise<T>, timeoutMs: number): Promise<T> => {
  return Promise.race([
    promise,
    new Promise<never>((_, reject) => 
      setTimeout(() => reject(new Error(`Operation timed out after ${timeoutMs}ms`)), timeoutMs)
    )
  ]);
};

// Helper function for retry logic
const withRetry = async <T>(
  operation: () => Promise<T>, 
  maxRetries: number = 3, 
  baseDelay: number = 1000
): Promise<T> => {
  let lastError: Error | null = null;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));
      
      if (attempt === maxRetries) {
        throw lastError;
      }
      
      // Exponential backoff: 1s, 2s, 4s
      const delay = baseDelay * Math.pow(2, attempt - 1);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  
  throw lastError || new Error('Unknown retry error');
};

export async function sfunc_create_image_with_openai({ prompt, userId, batchFolder, fileName, wipeMeta }: { prompt: string, userId: string, batchFolder: string, fileName?: string, wipeMeta: boolean }) {
  const supabase = createRouteHandlerClient({ cookies });
  
  // Log the start of image generation
  await logger.info({
    category: 'image_generation',
    message: `Starting OpenAI image generation`,
    details: { prompt: prompt.substring(0, 100) + '...', fileName, batchFolder },
    user_id: userId
  });
  
  try {
    // Get API key from api_keys_t1 table for this specific user
    const { data: apiKeyData, error: apiKeyError } = await supabase
      .from('api_keys_t1')
      .select('key_value')
      .eq('fk_users_id', userId)
      .eq('key_type', 'openai')
      .eq('is_active', true)
      .order('created_at', { ascending: false })
      .limit(1);

    if (apiKeyError) {
      const error = 'Database error: ' + apiKeyError.message;
      await logger.error({
        category: 'image_generation',
        message: 'Failed to fetch OpenAI API key',
        details: { error: apiKeyError.message },
        user_id: userId
      });
      return { success: false, error };
    }
    
    if (!apiKeyData || apiKeyData.length === 0) {
      const error = 'No active OpenAI API key found in api_keys_t1 table';
      await logger.error({
        category: 'image_generation',
        message: error,
        user_id: userId
      });
      return { success: false, error };
    }
    
    const apiKey = apiKeyData[0].key_value;
    if (!apiKey) {
      const error = 'OpenAI API key is empty in api_keys_t1 table';
      await logger.error({
        category: 'image_generation',
        message: error,
        user_id: userId
      });
      return { success: false, error };
    }

    // Initialize OpenAI client
    const openai = new OpenAI({ apiKey });
    
    // Step 1: Generate image with OpenAI (with timeout and retry)
    const response = await withRetry(async () => {
      return await withTimeout(
        openai.images.generate({
          model: 'dall-e-3',
          prompt,
          n: 1,
          size: '1024x1024',
        }),
        60000 // 60 second timeout for OpenAI API
      );
    }, 3, 2000); // 3 retries with 2s base delay
    
    if (!response.data || response.data.length === 0) {
      const error = 'No image generated by OpenAI';
      await logger.error({
        category: 'image_generation',
        message: error,
        details: { prompt: prompt.substring(0, 100) + '...' },
        user_id: userId
      });
      return { success: false, error };
    }
    
    const imageUrl = response.data[0].url;
    if (!imageUrl || typeof imageUrl !== 'string') {
      const error = 'OpenAI did not return a valid image URL';
      await logger.error({
        category: 'image_generation',
        message: error,
        details: { response: response.data[0] },
        user_id: userId
      });
      return { success: false, error };
    }

    await logger.info({
      category: 'image_generation',
      message: 'OpenAI image generated successfully, downloading...',
      details: { imageUrl: imageUrl.substring(0, 100) + '...' },
      user_id: userId
    });

    // Step 2: Download the image (with timeout and retry)
    const imageBuffer = await withRetry(async () => {
      const imageRes = await withTimeout(
        fetch(imageUrl),
        30000 // 30 second timeout for image download
      );
      
      if (!imageRes.ok) {
        throw new Error(`Failed to download image: ${imageRes.status} ${imageRes.statusText}`);
      }
      
      return await withTimeout(
        imageRes.arrayBuffer(),
        30000 // 30 second timeout for reading buffer
      );
    }, 3, 1000); // 3 retries with 1s base delay

    await logger.info({
      category: 'image_generation', 
      message: 'Image downloaded successfully, uploading to storage...',
      details: { bufferSize: imageBuffer.byteLength },
      user_id: userId
    });

    // Use provided fileName or fallback to timestamp
    let safeFileName = fileName && typeof fileName === 'string' && fileName.trim() ? fileName.trim() : `image_${Date.now()}.png`;
    // Ensure the filename is safe (no path traversal)
    safeFileName = safeFileName.replace(/[^a-zA-Z0-9._-]/g, '_');

    // Step 2.5: Strip metadata if requested
    let processedBuffer = imageBuffer;
    if (wipeMeta) {
      await logger.info({
        category: 'metadata_removal',
        message: 'Stripping metadata from generated image',
        details: { 
          originalSize: imageBuffer.byteLength,
          fileName: safeFileName 
        },
        user_id: userId
      });
      
      try {
        // Convert ArrayBuffer to Buffer and process with Sharp
        // @ts-ignore - Buffer type mismatch in serverless environment  
        let buffer = Buffer.from(new Uint8Array(imageBuffer));
        const image = sharp(buffer);
        const metadata = await image.metadata();
        
        // Reprocess the image based on its format to strip metadata
        if (metadata.format === 'jpeg') {
          // @ts-ignore - Buffer type mismatch in serverless environment
          buffer = Buffer.from(await image.jpeg().toBuffer());
        } else if (metadata.format === 'png') {
          // @ts-ignore - Buffer type mismatch in serverless environment
          buffer = Buffer.from(await image.png().toBuffer());
        } else if (metadata.format === 'webp') {
          // @ts-ignore - Buffer type mismatch in serverless environment
          buffer = Buffer.from(await image.webp().toBuffer());
        } else {
          // Default to PNG for unknown formats (since OpenAI generates PNG)
          // @ts-ignore - Buffer type mismatch in serverless environment
          buffer = Buffer.from(await image.png().toBuffer());
        }
        
        processedBuffer = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
        
        await logger.info({
          category: 'metadata_removal',
          message: 'Metadata stripped successfully',
          details: { 
            originalSize: imageBuffer.byteLength,
            processedSize: processedBuffer.byteLength,
            sizeDifference: imageBuffer.byteLength - processedBuffer.byteLength,
            fileName: safeFileName
          },
          user_id: userId
        });
      } catch (metadataError) {
        await logger.error({
          category: 'metadata_removal',
          message: 'Failed to strip metadata, using original image',
          details: { 
            error: metadataError instanceof Error ? metadataError.message : String(metadataError),
            fileName: safeFileName
          },
          user_id: userId
        });
        // Continue with original buffer if metadata stripping fails
        processedBuffer = imageBuffer;
      }
    }

    const storagePath = `barge1/${batchFolder}/${safeFileName}`;
    
    // Step 3: Upload to Supabase Storage (with timeout and retry)
    const uploadResult = await withRetry(async () => {
      return await withTimeout(
        supabase.storage
          .from('bucket-images-b1')
          .upload(storagePath, processedBuffer, {
            contentType: 'image/png',
            upsert: false,
          }),
        20000 // 20 second timeout for upload
      );
    }, 3, 1000); // 3 retries with 1s base delay
    
    if (uploadResult.error) {
      const error = 'Supabase Storage upload error: ' + uploadResult.error.message;
      await logger.error({
        category: 'image_generation',
        message: error,
        details: { storagePath, uploadError: uploadResult.error },
        user_id: userId
      });
      return { success: false, error };
    }

    // Get public URL
    const { data: publicUrlData } = supabase.storage
      .from('bucket-images-b1')
      .getPublicUrl(storagePath);

    await logger.info({
      category: 'image_generation',
      message: 'Image generation completed successfully',
      details: { 
        storagePath, 
        publicUrl: publicUrlData.publicUrl,
        fileName: safeFileName
      },
      user_id: userId
    });

    return { success: true, url: publicUrlData.publicUrl };
    
  } catch (error: any) {
    const errorMessage = error?.message || 'Unknown OpenAI error';
    await logger.error({
      category: 'image_generation',
      message: 'Image generation failed',
      details: { 
        error: errorMessage,
        prompt: prompt.substring(0, 100) + '...',
        fileName,
        batchFolder,
        stack: error?.stack
      },
      user_id: userId,
      stack_trace: error?.stack
    });
    
    return { success: false, error: errorMessage };
  }
} 