import OpenAI from 'openai';
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';
import { logger } from '@/lib/error-logger';

// Helper function to create a timeout promise
const withTimeout = <T>(promise: Promise<T>, timeoutMs: number): Promise<T> => {
  return Promise.race([
    promise,
    new Promise<never>((_, reject) => 
      setTimeout(() => reject(new Error(`Operation timed out after ${timeoutMs}ms`)), timeoutMs)
    )
  ]);
};

// Helper function for retry logic
const withRetry = async <T>(
  operation: () => Promise<T>, 
  maxRetries: number = 3, 
  baseDelay: number = 1000
): Promise<T> => {
  let lastError: Error | null = null;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));
      
      if (attempt === maxRetries) {
        throw lastError;
      }
      
      // Exponential backoff: 1s, 2s, 4s
      const delay = baseDelay * Math.pow(2, attempt - 1);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  
  throw lastError || new Error('Unknown retry error');
};

export async function sfunc_create_image_with_openai({ prompt, userId, batchFolder, fileName }: { prompt: string, userId: string, batchFolder: string, fileName?: string }) {
  const supabase = createRouteHandlerClient({ cookies });
  
  // Log the start of image generation
  await logger.info({
    category: 'image_generation',
    message: `Starting OpenAI image generation`,
    details: { prompt: prompt.substring(0, 100) + '...', fileName, batchFolder },
    user_id: userId
  });
  
  try {
    // Get API key from tapikeys2 table for this specific user
    const { data: apiKeyData, error: apiKeyError } = await supabase
      .from('tapikeys2')
      .select('key_value')
      .eq('fk_users_id', userId)
      .eq('key_type', 'openai')
      .eq('is_active', true)
      .order('created_at', { ascending: false })
      .limit(1);

    if (apiKeyError) {
      const error = 'Database error: ' + apiKeyError.message;
      await logger.error({
        category: 'image_generation',
        message: 'Failed to fetch OpenAI API key',
        details: { error: apiKeyError.message },
        user_id: userId
      });
      return { success: false, error };
    }
    
    if (!apiKeyData || apiKeyData.length === 0) {
      const error = 'No active OpenAI API key found in tapikeys2 table';
      await logger.error({
        category: 'image_generation',
        message: error,
        user_id: userId
      });
      return { success: false, error };
    }
    
    const apiKey = apiKeyData[0].key_value;
    if (!apiKey) {
      const error = 'OpenAI API key is empty in tapikeys2 table';
      await logger.error({
        category: 'image_generation',
        message: error,
        user_id: userId
      });
      return { success: false, error };
    }

    // Initialize OpenAI client
    const openai = new OpenAI({ apiKey });
    
    // Step 1: Generate image with OpenAI (with timeout and retry)
    const response = await withRetry(async () => {
      return await withTimeout(
        openai.images.generate({
          model: 'dall-e-3',
          prompt,
          n: 1,
          size: '1024x1024',
        }),
        60000 // 60 second timeout for OpenAI API
      );
    }, 3, 2000); // 3 retries with 2s base delay
    
    if (!response.data || response.data.length === 0) {
      const error = 'No image generated by OpenAI';
      await logger.error({
        category: 'image_generation',
        message: error,
        details: { prompt: prompt.substring(0, 100) + '...' },
        user_id: userId
      });
      return { success: false, error };
    }
    
    const imageUrl = response.data[0].url;
    if (!imageUrl || typeof imageUrl !== 'string') {
      const error = 'OpenAI did not return a valid image URL';
      await logger.error({
        category: 'image_generation',
        message: error,
        details: { response: response.data[0] },
        user_id: userId
      });
      return { success: false, error };
    }

    await logger.info({
      category: 'image_generation',
      message: 'OpenAI image generated successfully, downloading...',
      details: { imageUrl: imageUrl.substring(0, 100) + '...' },
      user_id: userId
    });

    // Step 2: Download the image (with timeout and retry)
    const imageBuffer = await withRetry(async () => {
      const imageRes = await withTimeout(
        fetch(imageUrl),
        30000 // 30 second timeout for image download
      );
      
      if (!imageRes.ok) {
        throw new Error(`Failed to download image: ${imageRes.status} ${imageRes.statusText}`);
      }
      
      return await withTimeout(
        imageRes.arrayBuffer(),
        30000 // 30 second timeout for reading buffer
      );
    }, 3, 1000); // 3 retries with 1s base delay

    await logger.info({
      category: 'image_generation', 
      message: 'Image downloaded successfully, uploading to storage...',
      details: { bufferSize: imageBuffer.byteLength },
      user_id: userId
    });

    // Use provided fileName or fallback to timestamp
    let safeFileName = fileName && typeof fileName === 'string' && fileName.trim() ? fileName.trim() : `image_${Date.now()}.png`;
    // Ensure the filename is safe (no path traversal)
    safeFileName = safeFileName.replace(/[^a-zA-Z0-9._-]/g, '_');
    const storagePath = `barge1/${batchFolder}/${safeFileName}`;
    
    // Step 3: Upload to Supabase Storage (with timeout and retry)
    const uploadResult = await withRetry(async () => {
      return await withTimeout(
        supabase.storage
          .from('bucket-images-b1')
          .upload(storagePath, imageBuffer, {
            contentType: 'image/png',
            upsert: false,
          }),
        20000 // 20 second timeout for upload
      );
    }, 3, 1000); // 3 retries with 1s base delay
    
    if (uploadResult.error) {
      const error = 'Supabase Storage upload error: ' + uploadResult.error.message;
      await logger.error({
        category: 'image_generation',
        message: error,
        details: { storagePath, uploadError: uploadResult.error },
        user_id: userId
      });
      return { success: false, error };
    }

    // Get public URL
    const { data: publicUrlData } = supabase.storage
      .from('bucket-images-b1')
      .getPublicUrl(storagePath);

    await logger.info({
      category: 'image_generation',
      message: 'Image generation completed successfully',
      details: { 
        storagePath, 
        publicUrl: publicUrlData.publicUrl,
        fileName: safeFileName
      },
      user_id: userId
    });

    return { success: true, url: publicUrlData.publicUrl };
    
  } catch (error: any) {
    const errorMessage = error?.message || 'Unknown OpenAI error';
    await logger.error({
      category: 'image_generation',
      message: 'Image generation failed',
      details: { 
        error: errorMessage,
        prompt: prompt.substring(0, 100) + '...',
        fileName,
        batchFolder,
        stack: error?.stack
      },
      user_id: userId,
      stack_trace: error?.stack
    });
    
    return { success: false, error: errorMessage };
  }
} 